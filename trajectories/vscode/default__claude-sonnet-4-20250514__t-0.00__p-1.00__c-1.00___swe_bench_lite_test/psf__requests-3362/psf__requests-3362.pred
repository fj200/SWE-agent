{"model_name_or_path": "default__claude-sonnet-4-20250514__t-0.00__p-1.00__c-1.00___swe_bench_lite_test", "instance_id": "psf__requests-3362", "model_patch": "diff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..948f4c60 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,19 +359,44 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n-        for item in iterator:\n-            yield item\n-        return\n-\n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n-    for chunk in iterator:\n-        rv = decoder.decode(chunk)\n+    # Determine encoding to use, with fallback logic similar to Response.text\n+    encoding = r.encoding\n+    if encoding is None:\n+        # Only try to get apparent_encoding if content is already consumed\n+        # to avoid consuming the stream prematurely\n+        if r._content_consumed:\n+            try:\n+                encoding = r.apparent_encoding\n+            except:\n+                # If apparent_encoding fails, use utf-8 as fallback\n+                encoding = 'utf-8'\n+        else:\n+            # For streaming case, use utf-8 as a reasonable default\n+            # This matches common web content and is backward compatible\n+            encoding = 'utf-8'\n+\n+    # If we still don't have an encoding, try utf-8 as fallback\n+    if encoding is None:\n+        encoding = 'utf-8'\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+        for chunk in iterator:\n+            rv = decoder.decode(chunk)\n+            if rv:\n+                yield rv\n+        rv = decoder.decode(b'', final=True)\n         if rv:\n             yield rv\n-    rv = decoder.decode(b'', final=True)\n-    if rv:\n-        yield rv\n+    except (LookupError, TypeError):\n+        # If the encoding is invalid, try to decode each chunk individually\n+        # with error handling, similar to what Response.text does\n+        for chunk in iterator:\n+            try:\n+                yield str(chunk, encoding, errors='replace')\n+            except (LookupError, TypeError):\n+                # Last resort: decode with default encoding and error replacement\n+                yield str(chunk, errors='replace')\n \n \n def iter_slices(string, slice_length):\n"}