{
    "pydata__xarray-4493": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "pydata__xarray-4493",
        "model_patch": "diff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 64c1895d..dc7348f1 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -204,6 +204,11 @@ def as_compatible_data(data, fastpath=False):\n     if isinstance(data, Variable):\n         return data.data\n \n+    # Check for DataArray and extract its data to preserve dask arrays\n+    from .dataarray import DataArray\n+    if isinstance(data, DataArray):\n+        return data.data\n+\n     if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n         return _maybe_wrap_data(data)\n \n"
    },
    "pytest-dev__pytest-6116": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "pytest-dev__pytest-6116",
        "model_patch": "diff --git a/src/_pytest/main.py b/src/_pytest/main.py\nindex 843c5b5f7..78c580395 100644\n--- a/src/_pytest/main.py\n+++ b/src/_pytest/main.py\n@@ -107,6 +107,7 @@ def pytest_addoption(parser):\n \n     group = parser.getgroup(\"collect\", \"collection\")\n     group.addoption(\n+        \"-C\",\n         \"--collectonly\",\n         \"--collect-only\",\n         action=\"store_true\",\n"
    },
    "sphinx-doc__sphinx-7738": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "sphinx-doc__sphinx-7738",
        "model_patch": "diff --git a/setup.py b/setup.py\nindex a427d5493..978e3d8e0 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):\n     sys.exit(1)\n \n install_requires = [\n-    'sphinxcontrib-applehelp',\n-    'sphinxcontrib-devhelp',\n+    'sphinxcontrib-applehelp<=1.0.7',\n+    'sphinxcontrib-devhelp<=1.0.5',\n     'sphinxcontrib-jsmath',\n-    'sphinxcontrib-htmlhelp',\n-    'sphinxcontrib-serializinghtml',\n-    'sphinxcontrib-qthelp',\n-    'Jinja2>=2.3',\n+    'sphinxcontrib-htmlhelp<=2.0.4',\n+    'sphinxcontrib-serializinghtml<=1.1.9',\n+    'sphinxcontrib-qthelp<=1.0.6',\n+    'Jinja2<3.0',\n     'Pygments>=2.0',\n     'docutils>=0.12',\n     'snowballstemmer>=1.1',\n     'babel>=1.3',\n-    'alabaster>=0.7,<0.8',\n+    'alabaster>=0.7,<0.7.12',\n     'imagesize',\n     'requests>=2.5.0',\n     'setuptools',\n-    'packaging',\n+    'packaging', 'markupsafe<=2.0.1',\n ]\n \n extras_require = {\ndiff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py\nindex 11409e6f6..b6ae73b07 100644\n--- a/sphinx/ext/napoleon/docstring.py\n+++ b/sphinx/ext/napoleon/docstring.py\n@@ -585,7 +585,12 @@ class GoogleDocstring:\n                 if _type:\n                     lines.append(':vartype %s: %s' % (_name, _type))\n             else:\n-                lines.append('.. attribute:: ' + _name)\n+                # For .. attribute:: directive, we don't need to escape trailing underscores\n+                # because the attribute name is not processed as reStructuredText text\n+                unescaped_name = _name\n+                if _name.endswith(r'\\_'):\n+                    unescaped_name = _name[:-2] + '_'\n+                lines.append('.. attribute:: ' + unescaped_name)\n                 if self._opt and 'noindex' in self._opt:\n                     lines.append('   :noindex:')\n                 if _type:\n@@ -645,7 +650,12 @@ class GoogleDocstring:\n     def _parse_methods_section(self, section: str) -> List[str]:\n         lines = []  # type: List[str]\n         for _name, _type, _desc in self._consume_fields(parse_type=False):\n-            lines.append('.. method:: %s' % _name)\n+            # For .. method:: directive, we don't need to escape trailing underscores\n+            # because the method name is not processed as reStructuredText text\n+            unescaped_name = _name\n+            if _name.endswith(r'\\_'):\n+                unescaped_name = _name[:-2] + '_'\n+            lines.append('.. method:: %s' % unescaped_name)\n             if self._opt and 'noindex' in self._opt:\n                 lines.append('   :noindex:')\n             if _desc:\ndiff --git a/tox.ini b/tox.ini\nindex d9f040544..bf39854b6 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -28,7 +28,7 @@ extras =\n setenv =\n     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils\n commands=\n-    pytest --durations 25 {posargs}\n+    pytest -rA --durations 25 {posargs}\n \n [testenv:flake8]\n basepython = python3\n"
    },
    "pylint-dev__pylint-6506": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "pylint-dev__pylint-6506",
        "model_patch": "diff --git a/pylint/__init__.py b/pylint/__init__.py\nindex 3aa4b7f9d..d79647552 100644\n--- a/pylint/__init__.py\n+++ b/pylint/__init__.py\n@@ -20,11 +20,15 @@ def run_pylint(argv: Sequence[str] | None = None) -> None:\n     argv can be a sequence of strings normally supplied as arguments on the command line\n     \"\"\"\n     from pylint.lint import Run as PylintRun\n+    from pylint.config.exceptions import _UnrecognizedOptionError\n \n     try:\n         PylintRun(argv or sys.argv[1:])\n     except KeyboardInterrupt:\n         sys.exit(1)\n+    except _UnrecognizedOptionError:\n+        print(\"For usage information, try: pylint --help\", file=sys.stderr)\n+        sys.exit(32)\n \n \n def run_epylint(argv: Sequence[str] | None = None) -> NoReturn:\n"
    },
    "mwaskom__seaborn-3407": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "mwaskom__seaborn-3407",
        "model_patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..2bc29e08 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1304,7 +1304,28 @@ class PairGrid(Grid):\n         self._add_axis_labels()\n \n         # Sort out the hue variable\n-        self._hue_var = hue\n+        # For MultiIndex columns, we need to store the actual column name\n+        # that pandas resolves to, not just the string that was passed in\n+        if hue is not None:\n+            # Get the actual column name by finding it in the columns\n+            # This handles the case where 'hue' becomes ('hue', '') in MultiIndex\n+            if hasattr(data.columns, 'get_loc'):\n+                try:\n+                    # This will work for both regular and MultiIndex columns\n+                    loc = data.columns.get_loc(hue)\n+                    if isinstance(loc, slice):\n+                        # For MultiIndex, get_loc might return a slice\n+                        actual_hue_col = data.columns[loc][0]\n+                    else:\n+                        actual_hue_col = data.columns[loc]\n+                    self._hue_var = actual_hue_col\n+                except (KeyError, IndexError):\n+                    # Fallback to original behavior\n+                    self._hue_var = hue\n+            else:\n+                self._hue_var = hue\n+        else:\n+            self._hue_var = hue\n         if hue is None:\n             self.hue_names = hue_order = [\"_nolegend_\"]\n             self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n@@ -1472,8 +1493,8 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n"
    },
    "scikit-learn__scikit-learn-11040": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "scikit-learn__scikit-learn-11040",
        "model_patch": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..5accabea6 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -7,6 +7,7 @@\n #\n # License: BSD 3 clause (C) INRIA, University of Amsterdam\n import warnings\n+import numbers\n from abc import ABCMeta, abstractmethod\n \n import numpy as np\n@@ -99,6 +100,17 @@ def _get_weights(dist, weights):\n                          \"'distance', or a callable function\")\n \n \n+def _check_n_neighbors(n_neighbors):\n+    \"\"\"Check to make sure n_neighbors is a valid integer\"\"\"\n+    if n_neighbors is None:\n+        raise ValueError(\"n_neighbors must be specified (got None)\")\n+    if not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+        raise TypeError(\"n_neighbors must be an integer, got %s\" % type(n_neighbors))\n+    if n_neighbors <= 0:\n+        raise ValueError(\"Expected n_neighbors > 0. Got %d\" % n_neighbors)\n+    return n_neighbors\n+\n+\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n@@ -252,13 +264,6 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n-        if self.n_neighbors is not None:\n-            if self.n_neighbors <= 0:\n-                raise ValueError(\n-                    \"Expected n_neighbors > 0. Got %d\" %\n-                    self.n_neighbors\n-                )\n-\n         return self\n \n     @property\n@@ -327,6 +332,8 @@ class KNeighborsMixin(object):\n \n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n+        \n+        n_neighbors = _check_n_neighbors(n_neighbors)\n \n         if X is not None:\n             query_is_train = False\n@@ -466,6 +473,8 @@ class KNeighborsMixin(object):\n         \"\"\"\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n+        \n+        n_neighbors = _check_n_neighbors(n_neighbors)\n \n         # kneighbors does the None handling.\n         if X is not None:\n"
    },
    "matplotlib__matplotlib-26020": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "matplotlib__matplotlib-26020",
        "model_patch": "diff --git a/lib/mpl_toolkits/axes_grid1/axes_grid.py b/lib/mpl_toolkits/axes_grid1/axes_grid.py\nindex 2b1b1d3200..d54a546248 100644\n--- a/lib/mpl_toolkits/axes_grid1/axes_grid.py\n+++ b/lib/mpl_toolkits/axes_grid1/axes_grid.py\n@@ -13,8 +13,24 @@ from .mpl_axes import Axes\n def _tick_only(ax, bottom_on, left_on):\n     bottom_off = not bottom_on\n     left_off = not left_on\n-    ax.axis[\"bottom\"].toggle(ticklabels=bottom_off, label=bottom_off)\n-    ax.axis[\"left\"].toggle(ticklabels=left_off, label=left_off)\n+    \n+    # Check if ax.axis is subscriptable and has the expected toggle method\n+    # (mpl_toolkits.axes_grid1.mpl_axes.Axes)\n+    try:\n+        if (hasattr(ax.axis, '__getitem__') and \n+            \"bottom\" in ax.axis and \"left\" in ax.axis and\n+            hasattr(ax.axis[\"bottom\"], 'toggle') and\n+            hasattr(ax.axis[\"left\"], 'toggle')):\n+            ax.axis[\"bottom\"].toggle(ticklabels=bottom_off, label=bottom_off)\n+            ax.axis[\"left\"].toggle(ticklabels=left_off, label=left_off)\n+        else:\n+            # For regular matplotlib axes (and subclasses like GeoAxes)\n+            ax.tick_params(bottom=bottom_on, labelbottom=bottom_on,\n+                          left=left_on, labelleft=left_on)\n+    except (TypeError, KeyError, AttributeError):\n+        # Fallback to tick_params for any unexpected axis attribute structure\n+        ax.tick_params(bottom=bottom_on, labelbottom=bottom_on,\n+                      left=left_on, labelleft=left_on)\n \n \n class CbarAxesBase:\ndiff --git a/lib/mpl_toolkits/axes_grid1/parasite_axes.py b/lib/mpl_toolkits/axes_grid1/parasite_axes.py\nindex cafd06adba..b53178228d 100644\n--- a/lib/mpl_toolkits/axes_grid1/parasite_axes.py\n+++ b/lib/mpl_toolkits/axes_grid1/parasite_axes.py\n@@ -5,6 +5,68 @@ from matplotlib.transforms import Bbox\n from .mpl_axes import Axes\n \n \n+def _set_axis_visibility(ax, axis_names, visible):\n+    \"\"\"\n+    Set visibility of axis/axes for both mpl_toolkits and regular matplotlib axes.\n+    \n+    Parameters\n+    ----------\n+    ax : Axes\n+        The axes instance\n+    axis_names : str or tuple of str\n+        Name(s) of the axis/axes to modify (\"left\", \"right\", \"top\", \"bottom\")\n+    visible : bool\n+        Whether to make the axis/axes visible\n+    \"\"\"\n+    if isinstance(axis_names, str):\n+        axis_names = (axis_names,)\n+    \n+    # Check if ax.axis is subscriptable and has the expected structure\n+    # (mpl_toolkits.axes_grid1.mpl_axes.Axes)\n+    try:\n+        if (hasattr(ax.axis, '__getitem__') and \n+            all(name in ax.axis for name in axis_names) and\n+            all(hasattr(ax.axis[name], 'set_visible') for name in axis_names)):\n+            # Use the mpl_toolkits axis interface\n+            if len(axis_names) == 1:\n+                ax.axis[axis_names[0]].set_visible(visible)\n+            else:\n+                ax.axis[axis_names].set_visible(visible)\n+        else:\n+            # Fallback for regular matplotlib axes\n+            _set_axis_visibility_fallback(ax, axis_names, visible)\n+    except (TypeError, KeyError, AttributeError):\n+        # Fallback for any unexpected axis attribute structure\n+        _set_axis_visibility_fallback(ax, axis_names, visible)\n+\n+\n+def _set_axis_visibility_fallback(ax, axis_names, visible):\n+    \"\"\"\n+    Fallback method to set axis visibility for regular matplotlib axes.\n+    \"\"\"\n+    for name in axis_names:\n+        if name in (\"left\", \"right\"):\n+            # Y-axis related\n+            if name == \"left\":\n+                ax.tick_params(left=visible, labelleft=visible)\n+                if hasattr(ax, 'spines') and 'left' in ax.spines:\n+                    ax.spines['left'].set_visible(visible)\n+            elif name == \"right\":\n+                ax.tick_params(right=visible, labelright=visible)\n+                if hasattr(ax, 'spines') and 'right' in ax.spines:\n+                    ax.spines['right'].set_visible(visible)\n+        elif name in (\"top\", \"bottom\"):\n+            # X-axis related\n+            if name == \"bottom\":\n+                ax.tick_params(bottom=visible, labelbottom=visible)\n+                if hasattr(ax, 'spines') and 'bottom' in ax.spines:\n+                    ax.spines['bottom'].set_visible(visible)\n+            elif name == \"top\":\n+                ax.tick_params(top=visible, labeltop=visible)\n+                if hasattr(ax, 'spines') and 'top' in ax.spines:\n+                    ax.spines['top'].set_visible(visible)\n+\n+\n class ParasiteAxesBase:\n \n     def __init__(self, parent_axes, aux_transform=None,\n@@ -158,9 +220,9 @@ class HostAxesBase:\n         will have ticks on the right.\n         \"\"\"\n         ax = self._add_twin_axes(axes_class, sharex=self)\n-        self.axis[\"right\"].set_visible(False)\n-        ax.axis[\"right\"].set_visible(True)\n-        ax.axis[\"left\", \"top\", \"bottom\"].set_visible(False)\n+        _set_axis_visibility(self, \"right\", False)\n+        _set_axis_visibility(ax, \"right\", True)\n+        _set_axis_visibility(ax, (\"left\", \"top\", \"bottom\"), False)\n         return ax\n \n     def twiny(self, axes_class=None):\n@@ -171,9 +233,9 @@ class HostAxesBase:\n         will have ticks on the top.\n         \"\"\"\n         ax = self._add_twin_axes(axes_class, sharey=self)\n-        self.axis[\"top\"].set_visible(False)\n-        ax.axis[\"top\"].set_visible(True)\n-        ax.axis[\"left\", \"right\", \"bottom\"].set_visible(False)\n+        _set_axis_visibility(self, \"top\", False)\n+        _set_axis_visibility(ax, \"top\", True)\n+        _set_axis_visibility(ax, (\"left\", \"right\", \"bottom\"), False)\n         return ax\n \n     def twin(self, aux_trans=None, axes_class=None):\n@@ -187,9 +249,9 @@ class HostAxesBase:\n             aux_trans = mtransforms.IdentityTransform()\n         ax = self._add_twin_axes(\n             axes_class, aux_transform=aux_trans, viewlim_mode=\"transform\")\n-        self.axis[\"top\", \"right\"].set_visible(False)\n-        ax.axis[\"top\", \"right\"].set_visible(True)\n-        ax.axis[\"left\", \"bottom\"].set_visible(False)\n+        _set_axis_visibility(self, (\"top\", \"right\"), False)\n+        _set_axis_visibility(ax, (\"top\", \"right\"), True)\n+        _set_axis_visibility(ax, (\"left\", \"bottom\"), False)\n         return ax\n \n     def _add_twin_axes(self, axes_class, **kwargs):\n"
    },
    "astropy__astropy-14995": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "astropy__astropy-14995",
        "model_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..98bc0f569c 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -522,6 +522,9 @@ class NDArithmeticMixin:\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif operand is not None and operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 15bb49f22b..dc9c3c5f37 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,5 +1,5 @@\n [build-system]\n-requires = [\"setuptools\",\n+requires = [\"setuptools==68.0.0\",\n             \"setuptools_scm>=6.2\",\n             \"cython==0.29.34\",\n             \"oldest-supported-numpy\",\n"
    },
    "django__django-17087": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "django__django-17087",
        "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex d88cda6e20..06657ebaab 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -168,7 +168,7 @@ class FunctionTypeSerializer(BaseSerializer):\n         ):\n             klass = self.value.__self__\n             module = klass.__module__\n-            return \"%s.%s.%s\" % (module, klass.__name__, self.value.__name__), {\n+            return \"%s.%s.%s\" % (module, klass.__qualname__, self.value.__name__), {\n                 \"import %s\" % module\n             }\n         # Further error checking\n"
    },
    "psf__requests-3362": {
        "model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test",
        "instance_id": "psf__requests-3362",
        "model_patch": "diff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..526eff2e 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,29 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    # Determine encoding to use - fallback to apparent_encoding if encoding is None\n+    encoding = r.encoding\n+    if encoding is None:\n+        try:\n+            encoding = r.apparent_encoding\n+        except (AttributeError, TypeError, LookupError):\n+            # If apparent_encoding fails for any reason, fall back to None\n+            encoding = None\n+\n+    # If we still don't have an encoding, just return the original items\n+    if encoding is None:\n+        for item in iterator:\n+            yield item\n+        return\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # If the encoding is invalid, fall back to returning original items\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n"
    }
}