{"model_name_or_path": "250526_anthropic_filemap_simple_review_sbl__claude-sonnet-4-20250514__t-0.00__p-1.00__c-5.00___swe_bench_lite_test", "instance_id": "psf__requests-3362", "model_patch": "diff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..526eff2e 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -359,12 +359,29 @@ def get_encoding_from_headers(headers):\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    # Determine encoding to use - fallback to apparent_encoding if encoding is None\n+    encoding = r.encoding\n+    if encoding is None:\n+        try:\n+            encoding = r.apparent_encoding\n+        except (AttributeError, TypeError, LookupError):\n+            # If apparent_encoding fails for any reason, fall back to None\n+            encoding = None\n+\n+    # If we still don't have an encoding, just return the original items\n+    if encoding is None:\n+        for item in iterator:\n+            yield item\n+        return\n+\n+    try:\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    except (LookupError, TypeError):\n+        # If the encoding is invalid, fall back to returning original items\n         for item in iterator:\n             yield item\n         return\n \n-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n         if rv:\n"}